
// kind definitions
let IS_COND		= 0x00001
let IS_CONTROL  = 0x00002
let IS_CALL     = 0x00004
let IS_RETURN	= 0x00008
let IS_MEM		= 0x00010
let IS_LOAD		= 0x00020
let IS_STORE    = 0x00040
let IS_INT		= 0x00080
let IS_FLOAT	= 0x00100
let IS_ALU		= 0x00200
let IS_MUL		= 0x00400
let IS_DIV		= 0x00800
let IS_SHIFT	= 0x01000
let IS_TRAP		= 0x02000
let IS_INTERN	= 0x04000
let IS_MULTI	= 0x08000
let IS_SPECIAL	= 0x10000
let IS_INDIRECT = 0x10000
let IS_UNKNOWN	= 0x20000
let IS_ATOMIC	= 0x40000
let IS_BUNDLE	= 0x80000


// simple ALU
extend
	add, addi, sub,
	and, andi, or, ori, xor, xori,
	sll, slli, sra, srai, srl, srli,
	slt, sltu, slti, sltiu,
	lui, auipc
		otawa_kind = IS_ALU | IS_INT

// integer division
extend
	div, divu,
	rem, remu
		otawa_kind = IS_ALU | IS_INT | IS_DIV

// integer multiplication
extend
	mul, mulh, mulhu, mulhsu
		otawa_kind = IS_ALU | IS_INT | IS_MUL

// inconditional branch and link
extend
	jal
		otawa_kind = IS_CONTROL | 
			(if dest == 0 then 0
			else if dest == 1 then IS_CALL
			else 0
			endif endif)

// indirect inconditional branch and link
extend
	jalr
		otawa_kind = IS_CONTROL |
			(if dest == 1 then IS_CALL
			else if dest == 0 && offset == 0 && base == 1 then IS_RETURN
			else if dest == 0 && offset == 0 && base != 1 then IS_INDIRECT
			else IS_CALL | IS_INDIRECT
			endif endif endif)


// simple conditional branch
extend
	beq, bne,
	blt, bltu,
	bge, bgeu
		otawa_kind = IS_CONTROL | IS_COND

// integer load
extend
	lb, lbu,
	lh, lhu,
	lw, lwu,
	ld
		otawa_kind = IS_MEM | IS_LOAD | IS_INT

// integer store
extend
	sb, sh, sw, sd
		otawa_kind = IS_MEM | IS_STORE | IS_INT

// internal instruction
extend
	fence
		otawa_kind = IS_INTERN

// control special instruction
extend
	syscall
		otawa_kind = IS_CONTROL | IS_TRAP
